% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ud_init.R
\name{ud_init}
\alias{ud_init}
\title{Initialize Ultimate Deconvolution Model}
\usage{
ud_init(
  dat,
  V,
  n_rank1,
  n_unconstrained,
  U_scaled,
  U_rank1,
  U_unconstrained,
  control = list()
)
}
\arguments{
\item{dat}{An n x m data matrix, in which each row of the matrix is
an m-dimensional data point, or a \dQuote{mash} object, for example
created by \code{\link[mashr]{mash_set_data}}. When \code{X} is a
matrix it should have at least 2 rows and at least 2 columns.}

\item{V}{Either an m x m matrix giving the residual covariance
matrix for all n data points, or a list of m x m covariance
matrices of length n.}

\item{n_rank1}{A non-negative integer specifying the number of
rank-1 covariance matrices included in the mixture prior. Initial
estimates of the m x m rank-1 covariance matrices are generated at
random. At most one of \code{n_rank1} and \code{U_rank1} should be
provided. If neither are specified, rank-1 matrices will not be
included.}

\item{n_unconstrained}{A non-negative integer specifying the number
of unconstrained covariance matrices included in the mixture
prior. Initial estimates of the m x m covariance matrices are
generated at random. At most one of \code{n_unconstrained} and
\code{U_unconstrained} should be provided. If neither are
specified, 4 random unconstrained matrices will be included.}

\item{U_scaled}{A list specifying initial estimates of the scaled
covariance matrices in the mixture prior. The default setting
specifies two commonly used covariance matrices. In the case of a
single scaled matrix, \code{U_scaled} may be a matrix instead of a
list.}

\item{U_rank1}{A list specifying initial estimates of the rank-1
matrices in the mixture prior. At most one of \code{n_rank1} and
\code{U_rank1} should be provided. If \code{U_rank1} is not given,
the rank-1 covariates are initialized at random. In the case of a
single rank-1 matrix, \code{U_rank1} may be a matrix instead of
list.}

\item{U_unconstrained}{A list specifying initial estimates of the
unconstrained matrices in the mixture prior. At most one of
\code{n_unconstrained} and \code{U_unconstrained} should be
provided. If \code{U_unconstrained} is not given, the matrices are
initialized at random. In the case of a single unconstrained
matrix, \code{U_unconstrained} may be a matrix instead of a list.}

\item{control}{A list of parameters controlling the behaviour of
the model initialization. See \code{\link{ud_fit}} for details.}
}
\value{
An Ultimate Deconvolution model fit. See
  \code{\link{ud_fit}} for details.
}
\description{
Initialize an Ultimate Deconvolution model fit. See
  \code{\link{ud_fit}} for background and model definition.
}
\examples{
# Here we illustrate the different ways to initialize a UD model fit,
# with and without mashr. In the very simplest invocation, we supply a
# data matrix X.
set.seed(1)
X <- matrix(rnorm(2000),200,10)
fit <- ud_init(X)

# For more sophisticated usage, first create a mash data object with
# mash_set_data, then call ud_init. By setting alpha = 1, we invoke
# the EZ ("exchangeable z-scores") model, and with the model the
# residual covariance matrix is the same for all effects (rows of
# Bhat), and is the same as the V in the mash object.
library(mashr)
V <- matrix(0.1,10,10)
diag(V) <- 1
Shat <- sqrt(matrix(rexp(2000),200,10))
out <- simple_sims(200,10,Shat)
dat <- mash_set_data(out$Bhat,out$Shat,V = V,alpha = 1)
fit <- ud_init(dat)
all.equal(dat$V,fit$V,check.attributes = FALSE)

# By setting alpha = 0, we instead use the EE ("exchangeable effects")
# model. Now the residual covariance is different for each effect, and
# these covariances are now stored in a list with one element for
# every row of Bhat (or X).
dat <- mash_set_data(out$Bhat,out$Shat,V = V,alpha = 0)
fit <- ud_init(dat)
class(fit$V)

# Again we use the EE model, but since the standard errors are the
# same for all the effects (and the s.e.'s are equal to 1), the
# residual covariance matrix is now the same for all effects.
dat <- mash_set_data(out$Bhat,Shat = 1,V = V,alpha = 0)
fit <- ud_init(dat)
all.equal(dat$V,fit$V,check.attributes = FALSE)

# In this final example, we customize the mixture prior to include
# different numbers of unconstrained and rank-1 matrices.
fit <- ud_init(dat,n_rank1 = 2,n_unconstrained = 4)
names(fit$U)

}
\seealso{
\code{\link{ud_fit}}
}
